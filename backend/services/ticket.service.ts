import type { DeepAnalysisReport, DiagnosticSummary, TicketTemplate, UpstreamReport } from "../../shared/types/index.ts";

export function generateTicket(summary: DiagnosticSummary, params: Record<string, unknown>): TicketTemplate {
  const title = generateTitle(summary);
  const body = generateBody(summary, params);
  const labels = generateLabels(summary);

  return { title, body, labels };
}

function generateTitle(summary: DiagnosticSummary): string {
  const engine = summary.deepAnalysis?.engine || "Unknown Engine";
  const status = summary.overallStatus;

  // Use suggested ticket title from deep analysis if available
  if (summary.deepAnalysis?.suggestedTicketTitle) {
    return summary.deepAnalysis.suggestedTicketTitle;
  }

  switch (status) {
    case "PARSER_FAIL":
      return `[${engine}] Parsing issue - data in HTML not present in JSON response`;
    case "UPSTREAM_BLOCK":
      return `[${engine}] Upstream blocking detected - CAPTCHA or rate limit`;
    default:
      return `[${engine}] Diagnostic report - ${new Date().toISOString().split("T")[0]}`;
  }
}

function generateBody(summary: DiagnosticSummary, params: Record<string, unknown>): string {
  const sections: string[] = [];

  sections.push("## Summary");
  sections.push(`- **Overall Status:** \`${summary.overallStatus}\``);
  sections.push(`- **Timestamp:** ${summary.timestamp}`);
  sections.push("");

  sections.push("## Reproduction Parameters");
  sections.push("```json");
  sections.push(JSON.stringify(params, null, 2));
  sections.push("```");
  sections.push("");

  if (summary.deepAnalysis) {
    sections.push(formatDeepAnalysisSection(summary.deepAnalysis));
  }

  if (summary.upstream) {
    sections.push(formatUpstreamSection(summary.upstream));
  }

  sections.push("---");
  sections.push("*Generated by SerpApi Diagnostic Workbench*");

  return sections.join("\n");
}

function formatDeepAnalysisSection(report: DeepAnalysisReport): string {
  const lines: string[] = [];
  lines.push("## Deep Analysis (HTML vs JSON)");
  lines.push(`- **Engine:** ${report.engine}`);
  lines.push(`- **HTML Fetched:** ${report.htmlComparison.htmlFetched ? "Yes" : "No"}`);
  if (report.htmlComparison.htmlSize) {
    lines.push(`- **HTML Size:** ${formatBytes(report.htmlComparison.htmlSize)}`);
  }
  lines.push(`- **Sections in HTML:** ${report.totalSectionsInHtml}`);
  lines.push(`- **Sections in JSON:** ${report.totalSectionsInJson}`);
  lines.push(`- **Missing in JSON:** ${report.totalMissing}`);
  lines.push(`- **Critical Missing:** ${report.criticalMissing}`);
  lines.push("");

  // HTML sections found
  if (report.htmlComparison.sectionsInHtml.length > 0) {
    lines.push("### Sections Found in HTML");
    lines.push("| Section | Count |");
    lines.push("|---------|-------|");
    for (const section of report.htmlComparison.sectionsInHtml) {
      lines.push(`| ${section.name} | ${section.count} |`);
    }
    lines.push("");
  }

  // JSON sections found
  if (report.htmlComparison.sectionsInJson.length > 0) {
    lines.push("### Sections Found in JSON");
    for (const section of report.htmlComparison.sectionsInJson) {
      lines.push(`- ${section}`);
    }
    lines.push("");
  }

  // Missing sections (THE IMPORTANT PART)
  if (report.htmlComparison.missingInJson.length > 0) {
    lines.push("### Missing in JSON (Parsing Bug!)");
    lines.push("| Section | Severity | HTML Count |");
    lines.push("|---------|----------|------------|");
    for (const missing of report.htmlComparison.missingInJson) {
      lines.push(`| ${missing.section} | ${missing.severity.toUpperCase()} | ${missing.htmlCount} |`);
    }
    lines.push("");
  }

  // Raw HTML link
  if (report.htmlComparison.htmlUrl) {
    lines.push(`[View Raw HTML](${report.htmlComparison.htmlUrl})`);
    lines.push("");
  }

  return lines.join("\n");
}

function formatUpstreamSection(report: UpstreamReport): string {
  const lines: string[] = [];
  lines.push("## Upstream Analysis");
  lines.push(`- **Content Type:** ${report.contentType}`);
  lines.push(`- **HTML Size:** ${formatBytes(report.htmlSize)}`);
  lines.push(`- **Blocked:** ${report.isBlocked ? "Yes" : "No"}`);
  lines.push(`- **Status:** \`${report.status}\``);

  if (report.alertMessage) {
    lines.push("");
    lines.push(`> **Alert:** ${report.alertMessage}`);
  }

  const foundPatterns = report.blockPatterns.filter((p) => p.found);
  if (foundPatterns.length > 0) {
    lines.push("");
    lines.push("### Blocking Patterns Found");
    for (const pattern of foundPatterns) {
      lines.push(`- **${pattern.pattern}**`);
      if (pattern.context) {
        lines.push(`  > \`${pattern.context}\``);
      }
    }
  }

  lines.push("");
  return lines.join("\n");
}

function formatBytes(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function generateLabels(summary: DiagnosticSummary): string[] {
  const labels: string[] = ["diagnostic"];

  switch (summary.overallStatus) {
    case "PARSER_FAIL":
      labels.push("parser-bug", "data-quality");
      break;
    case "UPSTREAM_BLOCK":
      labels.push("upstream", "blocking");
      break;
  }

  if (summary.deepAnalysis?.engine) {
    labels.push(`engine:${summary.deepAnalysis.engine}`);
  }

  // Add labels for missing sections
  if (summary.deepAnalysis?.htmlComparison.missingInJson) {
    for (const missing of summary.deepAnalysis.htmlComparison.missingInJson) {
      if (missing.severity === "critical") {
        labels.push(`missing:${missing.section}`);
      }
    }
  }

  return labels;
}
